<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>Suppress multithreaded correctness issues</Description>
    <Details>Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>Suppress internationalization issues</Description>
    <Details>Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>Suppress internationalization issues in all but selected packages</Description>
    <Details>Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>Suppress all issues with rank higher than 14</Description>
    <Details>Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>Probable bug - an apparent coding mistake
            resulting in code that was probably not what the
            developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>Bogus random noise: intended to be useful
    as a control in data mining experiments, not in finding actual bugs in software
            </Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>A use of untrusted input in a way that could create a remotely exploitable security vulnerability.
    </Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>Violations of recommended and essential
            coding practice. Examples include hash code and equals
            problems, cloneable idiom, dropped exceptions,
            Serializable problems, and misuse of finalize.
            We strive to make this analysis accurate,
            although some groups may
            not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>code that is confusing, anomalous, or
            written in a way that leads itself to errors.
            Examples include dead local stores, switch fall through,
            unconfirmed casts, and redundant null check of value
            known to be null.
            More false positives accepted.
            In previous versions of SpotBugs, this category was known as Style.
</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[
<p> Finds constants which roughly (but not precisely) equal to known values like Math.PI.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[
<p> Finds non-null fields that are not written to in constructors.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[
<p> Finds uses of 32-bit values to describe milliseconds since the epoch.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[
<p> Builds database of parameters that take a 64 bit value describing
milliseconds since the epoch.</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[
<p> This detector finds inconsistencies between type qualifiers directly
applied to method parameters and uses of those method parameters. </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[
<p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction
    that will not be executed atomically.
    </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[
<p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[
<p> This detector looks for a field that is synchronized on and then null checked.</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[
<p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[
<p> Looks for problems with arising from Java 1.5 varargs.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[
<p> Record annotations from the net.jcip.annotations package.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[
<p> Note the type qualifiers relevant to analyzing a method.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[
      <p>Builds the interprocedural call graph.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[
          <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[
<p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[
<p> Records annotation retention.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[
        <p>Records synthetic classes, methods, fields, etc.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[
<p> Builds a database of all methods defined in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[
<p> Try to determine which classes have constant references to their .class objects.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[
<p> Builds a database of all methods invoked in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[
<p> Looks for the methods which have no side effect, just return some value.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[
<p> Builds the database of string parameters passed from method to method unchanged.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[
<p> Looks for immutable classes with methods that return new instances of that class,
where people might accidentally think those methods mutate the instance they are invoked on.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[
<p> Looks for potential confusion between inherited and outer methods.</p>
]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[
<p> Looks for annotations to check return values of a method.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[
<p> Looks for code that synchronizes on the results of getClass rather than on class
literals.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[
      <p>
    This detector produces summary information for what is stored
    into fields.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
      Looks for @Nonnull annotations on methods, fields, and parameters.
      These can be used by the FindNullDeref detector to generate warnings
      when a possibly-null value is used in a context where only
      non-null values should be used.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
      dereference parameters unconditionally.  This information is used in
      a later analysis pass to find call sites where null values may
      be passed to those methods.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
    methods always return non-null values.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[
<p> Looks for methods with Boolean return type that return explicit null values.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[
<p> Looks for methods with Optional return type that return explicit null values.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[
<p> Looks for useless objects.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[
<p> Looks and warns about mutable enum fields.</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[
<p> Looks for cases where the return value of a function is discarded
after being checked for non-null.  </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[
<p> Looks for uses of this.getClass().getResource(...), which can give
unexpected results if the class is extended by a class in
another package. </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite recursive loop. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite loop. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[
<p> Looks for bug patterns in the usage of volatile fields. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[
<p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[
<p> This detector looks for anonymous inner classes that define methods
that are probably intended to but do not override methods in a superclass.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[
<p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[
<p> The equals and hashCode method on <code>java.net.URL</code> resolve
the domain name. As a result, these operations can be very expensive, and this
detector looks for places where those methods might be invoked.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[
<p> This detector looks for finalizers that null out fields of a class.
This does not help the garbage collector in any way, the nulling out of fields has no effect.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[
<p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[
<p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[
<p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods that are unsupported.
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[
<p> Checks for incorrect format strings.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[
<p> Checks for equals methods that check for their operand being an instance of a class
that is not compatible with the class defining the equals method.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[
<p> This detector finds code that behaves differently under OpenJDK 1.6, where
weak references are used to hold onto Loggers.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[
<p> This detector generates a random signal: warnings that are just based on
hash values of the operations performed by methods.
These warnings are bogus random noise, intended to be useful
        as a control in data mining experiments, not in finding actual bugs in software.

 This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[
<p> Noisy detector for null dereferences. Intended to be used as a control in experiments
about the validity or predictive ability of warnings, not as a way to find problems in code.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[
<p> This detector looks for string constants that are duplicated across multiple classfiles.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[
<p> Look for code that should be executed inside doPrivileged blocks.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[
<p> Checks that all references call be resolved.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[
<p> This detector looks for switch statements containing fall through.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for places where a field is assigned
by reading the value of the same field.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[
<p> This detector looks for suspicious uses of non-short-circuiting
boolean operators (<code>|</code> and <code>&amp;</code> instead of
<code>||</code> and <code>&amp;&amp;</code>).</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[
<p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[
<p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
cloneable classes. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
classes that implement <code>Comparator</code>. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> This detector looks for code where an exception is caught,
but nothing is done to handle the exception.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[
<p> Looks for loads of values known to be null.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[
<p> This detector looks for bad arguments being passed to methods
(e.g., substring(0)).
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> This detector looks for calls to pointless methods,
such as the no-argument String constructor.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[
<p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[
<p> Looks for calls to Number constructors with primitive arguments.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[
<p> This detector looks for calls to finalize() and other finalizer-related
issues.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[
<p> This detector looks for problems in the definition of the hashCode() and equals()
methods.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[
<p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to notify() that don't seem
to modify mutable object state.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[
<p> This detector looks for methods that return mutable static data.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[
<p> This detector looks for calls to Thread.run().  It is a fast
detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[
<p> This detector looks for loops that spin reading from a field.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() with two (or more) locks held.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() not in a conditional or loop.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[
<p> This detector looks for reads of uninitialized fields in constructors.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[
<p> This detector looks for get and set methods where the get is unsynchronized
while the set is synchronized.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[
<p> This detector looks for potentially circular class initialization
dependencies.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[
<p> This detector looks for problems in how Iterator classes are defined.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[
<p> This detector looks for comparisons of String objects using the == or !=
operators.
 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[
<p> This detector looks for synchronization on objects read from
modified fields.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[
<p> This detector looks for code that seems to be synchronizing on a field in order
to guard updates of that field.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[
<p> This detector looks for static fields that may be modified by
malicious code.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[
<p> This detector looks for suspiciously-named methods.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[
<p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
return value is ignored.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[
<p> This detector looks for potential problems in the implementation
of Serializable classes.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[
<p> This detector looks for constructors that start threads.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[
<p> This detector looks for incorrect for loops.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[
<p> Looks for explicit serialization via readObject and
    writeObject as evidence
that this class is, indeed, serialized. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[
<p> This detector looks for fields whose value is never read.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() that are not in a loop.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[
<p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur.  It also looks for redundant comparisons of reference values against
null.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur, and the use of non-short-circuit evaluation causes the usual techniques to fail.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> This detector looks for IO stream objects which do not escape the
method and do not appear to be closed on all paths out of the method.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> This detector looks for methods that return either arrays or an explicit null reference.
Returning a zero length array is generally preferred in this context to returning a null reference.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> This detector looks for control flow statements which have no effect.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
locks which are acquired, but not released on all paths out of the method.&nbsp;
It is a moderately fast detector.&nbsp; Note that in order to use this
detector, you need to have the <code>java.util.concurrent</code> package
in the auxiliary classpath (or be analyzing the package itself).</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where two reference values are compared
with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>)
where comparing reference values is generally an error.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait(), notify(), or notifyAll()
which do not appear to be made on an object which is currently locked.&nbsp;
It is a moderately fast detector.&nbsp; <b>This detector is disabled because
it is still under development, and produces too many false positives.</b></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[
<p> This detector looks for empty synchronized blocks.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[
<p> This detector looks for self assignments of local variables.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[
<p> This detector looks for suspicious bitwise logical expressions.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> This detector looks for lazy field initialization where the
field is not volatile.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[
<p> This detector looks for ordinary synchronization performed
on JSR166 locks.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[
<p> This detector looks for private methods that are never called.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[
<p> This detector looks for String concatenation in loops using +.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[
<p> This detector looks for objects initialized within loop which can be moved outside for better performance.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[
<p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String),
passing a constant string of length 1. It is recommended to use the more efficient integer implementations.
A fast detector.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[
<p> This detector looks for code that converts Collections to arrays
using the toArray() method that takes a prototype array, passing
an array argument which is zero-length.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientReplaceAll">
    <Details>
<![CDATA[
<p> This detector finds occurrences of replaceAll(String regex, String replacement) without any special regex characters. 
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[
<p> This detector looks for JUnit tests that are malformed.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[
<p> This detector looks for code that extends an Adapter class and overrides a Listener
method with the wrong signature. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[
<p> This detector looks for calls to getXXX or setXXX methods of a result set where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[
<p> This detector looks for type checks using the instanceof operator where the determination
can be done statically. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[
<p>
This detector looks for Applet constructors that call methods in the parent
Applet that rely on the Applet stub. Since this stub isn't initialized until just
before the init() method, these methods will fail in the constructor.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[
<p>
This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from
Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted().
However if it is called on an arbitrary thread object, it is most probably an error, as interrupted()
is always called on the current thread.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[
<p>
This detector uses data flow analysis to look for invocations of execute methods
on SQL statements in which something other than a constant string is passed as an argument.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[
<p>
This detector looks for assignments to local variables that
are never subsequently read. It is a moderately fast detector.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[
<p> This detector looks for class level fields that are masked by
local fields defined in methods.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[
<p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from
a keySet iterator. </p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[
<p> This detector looks for code that creates objects based on classes that only define static methods.
</p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[
<p> This detector looks for catch clauses that catch Exception,
when no code in the block throws Exception. </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[
<p> Looks for floating point equality expressions. A fast detector. </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[
<p>This detector looks for I/O streams and database resources that
are not cleaned up on all paths out of a method.  This is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[
<p>This detector looks for code that calls java.lang.Math static methods on constant values,
where the resultant value is a statically known constant. It is faster, and sometimes more
accurate, to use the constant instead.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[
<p>This detector looks for circular dependencies among classes. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[
<p>This detector looks for classes that declare they implement the same interface
as a super class. This is redundant, if a superclass implements an interface, so does
the subclass.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[
<p>This detector looks for potential problems in implementing the Struts framework.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[
<p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll()
on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class.
Clients of the class may use an instance of the class as its own synchronizing object, and cause
havoc to the base implementation.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[
<p>
This detector looks for places where the result of integer division is
cast to double. Often, what was meant was to cast the integer operands
to double and then perform the division.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[
<p>
This detector looks for bad casts of object references using data flow analysis.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[
<p>
This detector looks for stores of non Serializable objects into HTTP sessions.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[
<p>
This detector looks for uses of non Serializable objects in contexts that require them to be serializable.
</p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[
<p>
This detector looks for non Serializable objects passed to the writeObject method of
an ObjectOutput.
</p>
]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[
<p> This detector looks for regular expressions that have invalid syntax.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[
<p> This detector looks for miscellaneous small errors
mentioned by Joshua Bloch and Neal Gafter in
their work on Programming Puzzlers.
  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[
      <p>
         This detector looks for calls to Thread.sleep() made with
         a lock held.  It is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[
<p> This detector looks for if/else or switch statements that have the
same code for two branches, thus rendering the test useless. This often
is caused by copying and pasting the two branches, causing incorrect logic
for the one branch.</p><p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[
<p> This detector looks for internal classes that write to member variables of the
owning class, when that member variable is private. In this case, a special compiler
generated accessor method needs to be used to write to this variable. Relaxing the
visibility to protected will allow the field to be directly written.</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[
<p> This detector looks for direct allocations of implementations of XML interfaces.
This ties the code to a specific implementation, rather than using the supplied
factory pattern to create these objects.</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[
      <p>
      This detector looks for subclasses that implement methods defined in the super
      class, that only pass the parameters untouched to the parent class method.
      These methods can just be removed.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[
      <p>
      This detector looks for final classes that declare protected members. As this
      class can not be derived from, the use of protected access for members is
      incorrect. The access should be changed to public or private to represent
      the correct intention of the field. This was probably caused by a change in
      use for this class, without completely changing all of the class to the new
      paradigm.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[
      <p>
      This detector looks for simple assignments of literal boolean values to variables in
      conditional expressions.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[
      <p>
      TrainNullReturnValues determines which methods may return null and saves
      them to a file.  The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[
      <p>
      TrainUnconditionalParamDerefs determines which methods may
      unconditionally dereference parameters and saves them to a file.
      The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[
      <p>
      TrainFieldStoreTypes analyzes the types stored into fields
      and stores them to a database.  The database may be used in a later
      pass to make type analysis more precise.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
      TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations
      and stores them to database files.  This is a fast detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[
      <p>This detector is just for debugging method call resolution in SpotBugs.
      Don't enable it.</p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p> This detector just collects summary statistics information about the analysis process. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[
    <p>
    This detector is a code example showing how to write a SpotBugs
    detector using the ASM bytecode analysis framework.
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[
    <p> This detector looks at the arguments of calls to generic
    collection methods that receive a <code>java.lang.Object</code>
    to see if the argument's type is related to the collection's
    parameter. Arguments with unrelated class types are never going
    to be in the collection. For example, if <code>foo</code> is a
    <code>List&lt;String&gt;</code> and <code>bar</code> is a
    <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>
    will always return false. This is a fast detector.
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[
<p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because
 Calendars are inherently unsafe for multithreaded use.
</p>
]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[
          <p>This is an internal detector used only for testing dataflow analyses.
          It is not enabled by default.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[
        <p>Check for violations of properties specified by JSR-305
        type qualifier annotations.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[
        <p>Looks for an attempt to append to an object output stream.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[
          <p>Checks @ExpectedWarning and @NoWarning annotations.
          This detector is used only for testing SpotBugs.</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[
          <p>Checks that if the result of putIfAbsent is ignored,
            the value passed as the second argument is not reused. </p>
          ]]>
      </Details>
  </Detector>
  <Detector
    class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[
          <p>Checks for methods invoked from constructors for superclasses.  </p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[
<p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default
 platform encoding. This can cause the application behaviour to vary between platforms.  </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[
        <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values
        or @CheckForNull (made @Nonnull) on parameters.</p>
      ]]>
      </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>
      将数组声明为volatile类型, 他的子元素并不是volatile类型的
    </ShortDescription>
    <LongDescription>{1}数组被声明为volatile类型, 但是他的子元素并不是volatile类型的</LongDescription>
    <Details>
<![CDATA[
<p>This declares a volatile reference to an array, which might not be what
you want. With a volatile reference to an array, reads and writes of
the reference to the array are treated as volatile, but the array elements
are non-volatile. To get volatile array elements, you will need to use
one of the atomic array classes in java.util.concurrent (provided
in Java 5.0).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>
      对一个volatile类型的字段进行自增, 这种操作并不是原子性的
    </ShortDescription>
    <LongDescription>
      在{1}中, 对一个volatile类型的字段{2}进行自增, 这种操作并不是原子性的
    </LongDescription>
    <Details>
<![CDATA[
<p>This code increments a volatile field. Increments of volatile fields aren't
atomic. If more than one thread is incrementing the field at the same time,
increments could be lost.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>
      在返回值为Boolean类型的方法中返回null, 可能会导致使用者出现空指针异常
    </ShortDescription>
    <LongDescription>
      在返回值为Boolean类型的{1}方法中返回null, 可能会导致使用者出现空指针异常
    </LongDescription>
    <Details>
       <![CDATA[
       <p>
    A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen.
    This method can be invoked as though it returned a value of type boolean, and
    the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
    this will result in a NullPointerException.
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>
      在返回值为Optional类型的方法中返回null, 可能会导致使用者出现空指针异常
    </ShortDescription>
    <LongDescription>
      在返回值为Optional类型的方法{1}中返回null, 可能会导致使用者出现空指针异常
    </LongDescription>
    <Details>
       <![CDATA[
       <p>
    The usage of Optional return type (java.util.Optional or com.google.common.base.Optional)
    always means that explicit null returns were not desired by design.
    Returning a null value in such case is a contract violation and will most likely break client code.
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>
      在可能为null的对象进行Synchronize操作可能会出现空指针异常
    </ShortDescription>
    <LongDescription>
      在{1}方法中, 对象{2.givenClass}可能为null, 进行Synchronize操作可能会出现空指针异常
    </LongDescription>
    <Details>
<![CDATA[
<p>Since the field is synchronized on, it seems not likely to be null.
If it is null and then synchronized on a NullPointerException will be
thrown and the check would be pointless. Better to synchronize on
another field.</p>

]]>
     </Details>
  </BugPattern>

  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>可能会产生局部初始化的对象</ShortDescription>
    <LongDescription>{1}中可能会产生局部初始化的对象</LongDescription>
    <Details>
<![CDATA[
  <p>Looks like this method uses field initialization with double-checked locking.
  While the field is correctly declared as volatile, it's possible that the internal structure of
  the object is changed after the field assignment, thus another thread may see the partially initialized object.</p>
  <p>To fix this problem consider storing the object into the local variable first
  and save it to the volatile field only after it's fully constructed.
  </p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>
      方法没有检测参数是否为null
    </ShortDescription>
    <LongDescription>
      {1}方法没有检测参数是否为null
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>
      覆写的equals方法没有处理参数为空值的情况
    </ShortDescription>
    <LongDescription>
      覆写的equals方法{1}没有处理参数为空值的情况
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      This implementation of equals(Object) violates the contract defined
      by java.lang.Object.equals() because it does not check for null
      being passed as the argument.  All equals() methods should return
      false if passed a null value.
      </p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>在字段上进行循环可能会因为编译器重排导致死循环</ShortDescription>
    <LongDescription>在{1}的{2.givenClass}字段上进行循环可能会因为编译器重排导致死循环</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>
      在持有两个锁对象的情况下进行等待可能会发生死锁
    </ShortDescription>
    <LongDescription>{1}中在持有两个锁对象的情况下进行等待可能会发生死锁</LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.
   &nbsp;
   Performing a wait only releases the lock on the object
   being waited on, not any other locks.
   &nbsp;
This not necessarily a bug, but is worth examining
  closely.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>
      在构造函数中调用可能被子类重写的方法时, 这些方法可能还没有初始化
    </ShortDescription>
    <LongDescription>
      在构造函数中调用可能被子类重写的方法{2.name}时, {2.name}可能还没有初始化
    </LongDescription>
    <Details>
<![CDATA[
  <p> This method is invoked in the constructor of the superclass. At this point,
    the fields of the class have not yet initialized.</p>
<p>To make this more concrete, consider the following classes:</p>
<pre><code>abstract class A {
    int hashCode;
    abstract Object getValue();

    A() {
        hashCode = getValue().hashCode();
    }
}

class B extends A {
    Object value;

    B(Object v) {
        this.value = v;
    }

    Object getValue() {
        return value;
    }
}
</code></pre>
<p>When a <code>B</code> is constructed,
the constructor for the <code>A</code> class is invoked
<em>before</em> the constructor for <code>B</code> sets <code>value</code>.
Thus, when the constructor for <code>A</code> invokes <code>getValue</code>,
an uninitialized value is read for <code>value</code>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>
      set与get方法应该同时同步或同时不同步
    </ShortDescription>
    <LongDescription>
      {1}进行了同步, 而{2}确没有同步, 可能会出现多线程安全问题
    </LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>
      两个类的静态初始化块中存在交叉引用的情况, 可能导致初始化时发生异常
    </ShortDescription>
    <LongDescription>{0}和{1}两个类的静态初始化块中存在交叉引用的情况, 可能导致初始化时发生异常</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>
      内部类在外部类未初始化之前使用外部类对象实例
    </ShortDescription>
    <LongDescription>
      {0}的初始化过程中访问了类{2}, 此时{2}可能还未初始化
    </LongDescription>
    <Details>
<![CDATA[
  <p> During the initialization of a class, the class makes an active use of a subclass.
That subclass will not yet be initialized at the time of this use.
For example, in the following code, <code>foo</code> will be null.</p>
<pre><code>public class CircularClassInitialization {
    static class InnerClassSingleton extends CircularClassInitialization {
        static InnerClassSingleton singleton = new InnerClassSingleton();
    }

    static CircularClassInitialization foo = InnerClassSingleton.singleton;
}
</code></pre>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>
      由于String变量是多个对象所共有, 同步String型变量可能会引发死锁
    </ShortDescription>
    <LongDescription>
      由于String变量是多个对象所共有, 在{1}中同步String型变量可能会引发死锁
    </LongDescription>
    <Details>
<![CDATA[
  <p> The code synchronizes on interned String.</p>
<pre><code>private static String LOCK = "LOCK";
...
synchronized(LOCK) {
    ...
}
...
</code></pre>
<p>Constant Strings are interned and shared across all other classes loaded by the JVM. Thus, this code
is locking on something that other code might also be locking. This could result in very strange and hard to diagnose
blocking and deadlock behavior. See <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> and <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.
</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>
      Boolean型变量实例可能会被其他类使用, Boolean型变量上同步可能会导致不必要的竞争甚至死锁
    </ShortDescription>
    <LongDescription>
      Boolean型变量实例可能会被其他类使用, Boolean型变量{1}上同步可能会导致不必要的竞争甚至死锁
    </LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as a Boolean.</p>
<pre><code>private static Boolean inited = Boolean.FALSE;
...
synchronized(inited) {
    if (!inited) {
        init();
        inited = Boolean.TRUE;
    }
}
...
</code></pre>
<p>Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock.</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>
      封装型变量实例可能会被其他类使用, 封装型变量上同步可能会导致不必要的竞争甚至死锁
    </ShortDescription>
    <LongDescription>
      封装型变量实例可能会被其他类使用, 封装型变量{1}上同步可能会导致不必要的竞争甚至死锁
    </LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as an Integer.</p>
<pre><code>private static Integer count = 0;
...
synchronized(count) {
    count++;
}
...
</code></pre>
<p>Since Integer objects can be cached and shared,
this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock.</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>对一个可变的对象进行同步操作可能是无效的</ShortDescription>
    <LongDescription>对一个可变的对象{2.givenClass}进行同步操作可能是无效的</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on a field in what appears to be an attempt
to guard against simultaneous updates to that field. But guarding a field
gets a lock on the referenced object, not on the field. This may not
provide the mutual exclusion you need, and other threads might
be obtaining locks on the referenced objects (for other purposes). An example
of this pattern would be:</p>
<pre><code>private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
     Long result = null;
     synchronized(myNtfSeqNbrCounter) {
         result = new Long(myNtfSeqNbrCounter.longValue() + 1);
         myNtfSeqNbrCounter = new Long(result.longValue());
     }
     return result;
}
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>对一个可变的对象进行同步操作可能是无效的</ShortDescription>
    <LongDescription>
      对一个可变的对象{2.givenClass}进行同步操作可能是无效的
    </LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object
   referenced from a mutable field.
   This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>
      readline方法可能返回空值, 使用之前进行空值检查可以有效避免空指针异常
    </ShortDescription>
    <LongDescription>
      readline方法可能返回空值, 使用之前进行空值检查可以有效避免空指针异常
    </LongDescription>
    <Details>
<![CDATA[
  <p> The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>
      该字段未被初始化过
    </ShortDescription>
    <LongDescription>
      {2.name}字段未被初始化过
    </LongDescription>
    <Details>
<![CDATA[
  <p> The program is dereferencing a field that does not seem to ever have a non-null value written to it.
Unless the field is initialized via some mechanism not seen by the analysis,
dereferencing this value will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>对象在此处的值可能为空, 直接引用可能会抛出空指针异常</ShortDescription>
    <LongDescription>
      对象{2.givenClass}在此处的值可能为空, 直接引用可能会抛出空指针异常
    </LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a
<code>NullPointerException</code> when the code is executed.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>
      变量带有Notnull注解, 不要用一个可能为空的空值对其进行赋值
    </ShortDescription>
    <LongDescription>
      变量{2.givenClass}带有Notnull注解, 不要用一个可能为空的空值对其进行赋值
    </LongDescription>
    <Details>
      <![CDATA[
<p> A value that could be null is stored into a field that has been annotated as @Nonnull. </p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>
      函数参数带有Nullable注解, 但是函数使用中并未进行空值判断
    </ShortDescription>
    <LongDescription>
      函数参数{2}带有Nullable注解, 但是函数使用中并未进行空值判断
    </LongDescription>
    <Details>
<![CDATA[
<p> This parameter is always used in a way that requires it to be non-null,
but the parameter is explicitly annotated as being Nullable. Either the use
of the parameter or the annotation is wrong.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>可能为空值的参数传递给了带有非空值参数的方法</ShortDescription>
    <LongDescription>可能为空值的参数传递给了带有非空值参数的方法</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method call passes a null value for a non-null method parameter.
    Either the parameter is annotated as a parameter that should
    always be non-null, or analysis has shown that it will always be
    dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>
      通常来说克隆方法的返回值不应该为空
    </ShortDescription>
    <LongDescription>
      通常来说克隆方法的返回值不应该为空
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    This clone method seems to return null in some circumstances, but clone is never
    allowed to return a null value.  If you are convinced this path is unreachable, throw an AssertionError
    instead.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>通常来说toString方法的返回值不应该为空</ShortDescription>
    <LongDescription>通常来说toString方法的返回值不应该为空</LongDescription>
    <Details>
      <![CDATA[
      <p>
    This toString method seems to return null in some circumstances. A liberal reading of the
    spec could be interpreted as allowing this, but it is probably a bad idea and could cause
    other code to break. Return the empty string or some other appropriate string rather than null.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>此处变量可能为Null, 直接使用会出现空指针异常</ShortDescription>
    <LongDescription>变量{2.givenClass}可能为Null, 直接使用会出现空指针异常</LongDescription>
    <Details>
          <![CDATA[
              <p>
              There is a statement or branch that if executed guarantees that
              a value is null at this point, and that
              value that is guaranteed to be dereferenced
              (except on forward paths involving runtime exceptions).
              </p>
        <p>Note that a check such as
            <code>if (x == null) throw new NullPointerException();</code>
            is treated as a dereference of <code>x</code>.</p>
          ]]>
      </Details>
  </BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>
      不要在所有的static final字段赋值之前, 去使用静态初始化的方法创建一个类的实例
    </ShortDescription>
    <LongDescription>
      不要在所有的static final字段赋值之前, 去使用静态初始化的方法创建一个类的实例{0}
    </LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>控制语句后面跟着空语句, 是设计如此吗</ShortDescription>
    <LongDescription>控制语句后面跟着空语句, 是设计如此吗</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement in which control
flow follows to the same or following line regardless of whether or not
the branch is taken.
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:</p>
<pre><code>if (argv.length == 1);
    System.out.println("Hello, " + argv[0]);
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>equals的参数必定为null</ShortDescription>
    <LongDescription>equals的参数必定为null</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object), passing a null value as
the argument. According to the contract of the equals() method,
this call should always return <code>false</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>把函数参数赋值给了参数自己, 是不是忘记写this了</ShortDescription>
    <LongDescription>把函数参数赋值给了参数自己, 是不是忘记写this了</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable, and there
is a field with an identical name.
assignment appears to have been ; e.g.</p>
<pre><code>    int foo;
    public void setFoo(int foo) {
        foo = foo;
    }
</code></pre>
<p>The assignment is useless. Did you mean to assign to the field instead?</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>这个延迟加载的字段在多线程情况下可能会遇到问题</ShortDescription>
    <LongDescription>这个延迟加载的字段在多线程情况下可能会遇到问题</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>这个延迟加载的字段在多线程情况下可能会遇到问题</ShortDescription>
    <LongDescription>这个延迟加载的字段在多线程情况下可能会遇到问题</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a static field.
After the field is set, the object stored into that location is further updated or accessed.
The setting of the field is visible to other threads as soon as it is set. If the
further accesses in the method that set the field serve to initialize the object, then
you have a <em>very serious</em> multithreading bug, unless something else prevents
any other thread from accessing the stored object until it is fully initialized.
</p>
<p>Even if you feel confident that the method is never called by multiple
threads, it might be better to not set the static field until the value
you are setting it to is fully populated/initialized.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>sql返回的resultset中获取第0个元素会取得错误结果</ShortDescription>
    <LongDescription>sql返回的resultset中获取第0个元素会取得错误结果</LongDescription>
    <Details>
<![CDATA[
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>prepared statement中使用第0个元素会取得错误结果</ShortDescription>
    <LongDescription>prepared statement中使用第0个元素会取得错误结果</LongDescription>
    <Details>
<![CDATA[
<p> A call to a setXXX method of a prepared statement was made where the
parameter index is 0. As parameter indexes start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>
      负数无法通过取余数为1来判断是否为奇数
    </ShortDescription>
    <LongDescription>Check for oddness that won't work for negative numbers in {1}
      负数无法通过取余数为1来判断是否为奇数
    </LongDescription>
    <Details>
<![CDATA[
<p>
The code uses x % 2 == 1 to check to see if a value is odd, but this won't work
for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check
for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>
      在持有对象锁时进行睡眠可能会导致死锁情况
    </ShortDescription>
    <LongDescription>
      在持有对象锁时进行睡眠可能会导致死锁情况
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method calls Thread.sleep() with a lock held.  This may result
      in very poor performance and scalability, or a deadlock, since other threads may
      be waiting to acquire the lock.  It is a much better idea to call
      wait() on the lock, which releases the lock and allows other threads
      to run.
      </p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>
      实例的方法中同步时直接使用类名同步可能会出现意外情况, 如果这个类有子类, 那么这些子类的实例将会在同一个对象上进行同步, 这不是我们想要的效果, 可以使用getClass方法代替
    </ShortDescription>
    <LongDescription>
      实例的方法中同步时直接使用类名同步可能会出现意外情况, 如果这个类有子类, 那么这些子类的实例将会在同一个对象上进行同步, 这不是我们想要的效果, 可以使用getClass方法代替
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
     This instance method synchronizes on <code>this.getClass()</code>. If this class is subclassed,
     subclasses will synchronize on the class object for the subclass, which isn't likely what was intended.
     For example, consider this code from java.awt.Label:</p>
<pre><code>private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (getClass()) {
        return base + nameCounter++;
    }
}
</code></pre>
     <p>Subclasses of <code>Label</code> won't synchronize on the same subclass, giving rise to a datarace.
     Instead, this code should be synchronizing on <code>Label.class</code></p>
<pre><code>private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (Label.class) {
        return base + nameCounter++;
    }
}
</code></pre>
      <p>Bug pattern contributed by Jason Mehrens</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>
      该资源使用结束后没有进行释放
    </ShortDescription>
    <LongDescription>
      资源{2}使用结束后没有进行释放
    </LongDescription>
    <Details>
          <![CDATA[
          <p>
          This method may fail to clean up (close, dispose of) a stream,
          database object, or other
          resource requiring an explicit cleanup operation.
          </p>

          <p>
          In general, if a method opens a stream or other resource,
          the method should use a try/finally block to ensure that
          the stream or resource is cleaned up before the method
          returns.
          </p>

          <p>
          This bug pattern is essentially the same as the
          OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
          bug patterns, but is based on a different
          (and hopefully better) static analysis technique.
          We are interested is getting feedback about the
          usefulness of this bug pattern.
          For sending feedback, check:
          </p>
          <ul>
            <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">contributing guideline</a></li>
            <li><a href="https://github.com/spotbugs/discuss/issues?q=">malinglist</a></li>
          </ul>

          <p>
          In particular,
          the false-positive suppression heuristics for this
          bug pattern have not been extensively tuned, so
          reports about false positives are helpful to us.
          </p>

          <p>
          See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
          a description of the analysis technique.
          </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>异常路径上, 该资源使用结束后没有进行释放</ShortDescription>
    <LongDescription>异常路径上, 资源{2}使用结束后没有进行释放</LongDescription>
    <Details>
          <![CDATA[
          <p>
          This method may fail to clean up (close, dispose of) a stream,
          database object, or other
          resource requiring an explicit cleanup operation.
          </p>

          <p>
          In general, if a method opens a stream or other resource,
          the method should use a try/finally block to ensure that
          the stream or resource is cleaned up before the method
          returns.
          </p>

          <p>
          This bug pattern is essentially the same as the
          OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
          bug patterns, but is based on a different
          (and hopefully better) static analysis technique.
          We are interested is getting feedback about the
          usefulness of this bug pattern.
          For sending feedback, check:
          </p>
          <ul>
            <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">contributing guideline</a></li>
            <li><a href="https://github.com/spotbugs/discuss/issues?q=">malinglist</a></li>
          </ul>

          <p>
          In particular,
          the false-positive suppression heuristics for this
          bug pattern have not been extensively tuned, so
          reports about false positives are helpful to us.
          </p>

          <p>
          See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
          a description of the analysis technique.
          </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>发生异常时, 没有释放锁</ShortDescription>
    <LongDescription>{1} 发生异常时, 没有释放锁</LongDescription>
    <Details>
      <![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
</p>
<pre><code>Lock l = ...;
l.lock();
try {
    // do something
} finally {
    l.unlock();
}
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_JSON_OBJECT_MIGHT_BE_NULL_BUT_DEREFED">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 对该对象的调用可能会产生空指针异常, 请进行Null Check
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性{2}有可能为null, 对该对象的调用可能会产生空指针异常, 推荐进行空值检查之后再使用
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PASS_JSON_FIELD_TO_NONNULL_PARAM">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 而目标方法中对该对象没有进行控制检查, 这种情况下有可能出现空指针异常
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性{4}有可能为null, 而目标方法{2}的第{5}个参数不能为null, 这种情况下有可能出现空指针异常
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_JSON_OBJECT_MIGHT_BE_NULL_BUT_DEREFED_EXP">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 对该对象的调用可能会产生空指针异常, 请进行Null Check
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性{2}有可能为null, 对该对象的调用可能会产生空指针异常, 推荐进行空值检查之后再使用
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PASS_JSON_FIELD_TO_NONNULL_PARAM_EXP">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 而目标方法中对该对象没有进行控制检查, 这种情况下有可能出现空指针异常
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性{4}有可能为null, 而目标方法{2}的第{5}个参数不能为null, 这种情况下有可能出现空指针异常
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">Analysis skipped</BugCode>
  <BugCode abbrev="IL">Infinite Loop</BugCode>
  <BugCode abbrev="VO">Use of volatile</BugCode>
  <BugCode abbrev="UI">Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">Covariant array assignment</BugCode>
  <BugCode abbrev="AT">Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">Input/Output problem</BugCode>
  <BugCode abbrev="IC">Initialization circularity</BugCode>
  <BugCode abbrev="SI">Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">Mutable servlet field</BugCode>
  <BugCode abbrev="IS">Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API misuse</BugCode>
  <BugCode abbrev="Dm">Dubious method used</BugCode>
  <BugCode abbrev="Bx">Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">Naked notify</BugCode>
  <BugCode abbrev="UW">Unconditional wait</BugCode>
  <BugCode abbrev="SP">Method spins on field</BugCode>
  <BugCode abbrev="DC">Double check pattern</BugCode>
  <BugCode abbrev="Wa">Wait not in loop</BugCode>
  <BugCode abbrev="No">Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">Method invokes run()</BugCode>
  <BugCode abbrev="It">Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">Mutable static field</BugCode>
  <BugCode abbrev="ME">Mutable enum field</BugCode>
  <BugCode abbrev="EI">Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">Confusing method name</BugCode>
  <BugCode abbrev="SS">Unread field should be static</BugCode>
  <BugCode abbrev="UuF">Unused field</BugCode>
  <BugCode abbrev="UrF">Unread field</BugCode>
  <BugCode abbrev="UwF">Unwritten field</BugCode>
  <BugCode abbrev="SIC">Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">Range checks</BugCode>
  <BugCode abbrev="RV">Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">Logger problem</BugCode>
  <BugCode abbrev="IA">Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">Path traversal</BugCode>
  <BugCode abbrev="XSS">Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">Bogus random warning</BugCode>
  <BugCode abbrev="RpC">Repeated conditional test</BugCode>
  <BugCode abbrev="OS">Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-operation</BugCode>
  <BugCode abbrev="INT">Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">Private method is never called</BugCode>
  <BugCode abbrev="UMAC">Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing coding rules</BugCode>
  <BugCode abbrev="IJU">Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">Switch case falls through</BugCode>
  <BugCode abbrev="SIO">Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">Use Object Equals</BugCode>
  <BugCode abbrev="STI">Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">Dead local store</BugCode>
  <BugCode abbrev="IP">Ignored parameter</BugCode>
  <BugCode abbrev="MF">Masked Field</BugCode>
  <BugCode abbrev="WMI">Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">RuntimeException capture</BugCode>
  <BugCode abbrev="FE">Test for floating point equality</BugCode>
  <BugCode abbrev="UM">Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">Useless code</BugCode>
  <BugCode abbrev="CNT">Rough value of known constant</BugCode>
  <BugCode abbrev="CD">Circular Dependencies</BugCode>
  <BugCode abbrev="RI">Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">Bad shift</BugCode>
  <BugCode abbrev="ICAST">Casting from integer values</BugCode>
  <BugCode abbrev="RE">Regular expressions</BugCode>
  <BugCode abbrev="SQL">Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">Questionable for loops</BugCode>
  <BugCode abbrev="VA">Vararg problems</BugCode>
  <BugCode abbrev="BC">Bad casts of object references</BugCode>
  <BugCode abbrev="IM">Questionable integer math</BugCode>
  <BugCode abbrev="ST">Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE error</BugCode>
  <BugCode abbrev="DB">Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">Version compatibility issue</BugCode>
  <BugCode abbrev="DP">Use doPrivileged</BugCode>
  <BugCode abbrev="GC">Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">Unintended contention or possible deadlock due to locking on shared objects</BugCode>
</MessageCollection>
