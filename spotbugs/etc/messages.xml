<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Core SpotBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard SpotBugs detectors.
</p>
]]>
    </Details>
    <BugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>Add msgs (e.g., textual descriptions of bugs) to analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>Perform SpotBugs Analysis</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>Launch SpotBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>Convert analysis results to textual form</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>Provide help for commands</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>List SpotBugs version</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>Filter analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>Set project configuration/options</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>List details from multi-version analysis results</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>Merge analysis results from disjoint components</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>Combine analysis results from different versions of software to produce multi-version analysis results</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>Disassemble a class file</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>List analysis errors stored in results file</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(cloud disabled)</Description>
    <Details>Bug reviews are disabled when using this plugin.</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>Suppress multithreaded correctness issues</Description>
    <Details>Suppress all multithreaded correctness issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>Suppress internationalization issues</Description>
    <Details>Suppress all internationalization issues</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>Suppress internationalization issues in all but selected packages</Description>
    <Details>Suppress all internationalization issues except those specified in the i18n.properties resource</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>Suppress all issues with rank higher than 14</Description>
    <Details>Suppress all issues with rank higher than 14</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>Suppress warnings about vulnerabilities to malicious code</Description>
    <Details>Suppress warnings about vulnerabilities to malicious code</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>Probable bug - an apparent coding mistake
            resulting in code that was probably not what the
            developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>Bogus random noise: intended to be useful
    as a control in data mining experiments, not in finding actual bugs in software
            </Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>A use of untrusted input in a way that could create a remotely exploitable security vulnerability.
    </Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>Violations of recommended and essential
            coding practice. Examples include hash code and equals
            problems, cloneable idiom, dropped exceptions,
            Serializable problems, and misuse of finalize.
            We strive to make this analysis accurate,
            although some groups may
            not care about some of the bad practices.</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>code that is confusing, anomalous, or
            written in a way that leads itself to errors.
            Examples include dead local stores, switch fall through,
            unconfirmed casts, and redundant null check of value
            known to be null.
            More false positives accepted.
            In previous versions of SpotBugs, this category was known as Style.
</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[
<p> Finds constants which roughly (but not precisely) equal to known values like Math.PI.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[
<p> Finds non-null fields that are not written to in constructors.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[
<p> Finds uses of 32-bit values to describe milliseconds since the epoch.
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[
<p> Builds database of parameters that take a 64 bit value describing
milliseconds since the epoch.</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[
<p> This detector finds inconsistencies between type qualifiers directly
applied to method parameters and uses of those method parameters. </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[
<p> Finds sequences of operations (e.g., get/put) on a concurrent abstraction
    that will not be executed atomically.
    </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[
<p> This detector looks for synchronization on a shared built-in constant (such as a String).</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[
<p> This detector looks for a field that is synchronized on and then null checked.</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[
<p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[
<p> Looks for problems with arising from Java 1.5 varargs.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[
<p> Record annotations from the net.jcip.annotations package.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[
<p> Note the type qualifiers relevant to analyzing a method.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[
      <p>Builds the interprocedural call graph.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[
          <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[
<p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[
<p> Records annotation retention.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[
        <p>Records synthetic classes, methods, fields, etc.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[
<p> Builds a database of all methods defined in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[
<p> Try to determine which classes have constant references to their .class objects.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[
<p> Builds a database of all methods invoked in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[
<p> Looks for the methods which have no side effect, just return some value.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[
<p> Builds the database of string parameters passed from method to method unchanged.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[
<p> Looks for immutable classes with methods that return new instances of that class,
where people might accidentally think those methods mutate the instance they are invoked on.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[
<p> Looks for potential confusion between inherited and outer methods.</p>
]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[
<p> Looks for annotations to check return values of a method.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[
<p> Looks for code that synchronizes on the results of getClass rather than on class
literals.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[
      <p>
    This detector produces summary information for what is stored
    into fields.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
      Looks for @Nonnull annotations on methods, fields, and parameters.
      These can be used by the FindNullDeref detector to generate warnings
      when a possibly-null value is used in a context where only
      non-null values should be used.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
      dereference parameters unconditionally.  This information is used in
      a later analysis pass to find call sites where null values may
      be passed to those methods.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
    methods always return non-null values.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildJsonReturnDatabase">
    <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
    methods always return json values.
      </p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[
<p> Looks for methods with Boolean return type that return explicit null values.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[
<p> Looks for methods with Optional return type that return explicit null values.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[
<p> Looks for useless objects.</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[
<p> Looks and warns about mutable enum fields.</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[
<p> Looks for cases where the return value of a function is discarded
after being checked for non-null.  </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[
<p> Looks for uses of this.getClass().getResource(...), which can give
unexpected results if the class is extended by a class in
another package. </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite recursive loop. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite loop. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[
<p> Looks for bug patterns in the usage of volatile fields. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[
<p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[
<p> This detector looks for anonymous inner classes that define methods
that are probably intended to but do not override methods in a superclass.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[
<p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[
<p> The equals and hashCode method on <code>java.net.URL</code> resolve
the domain name. As a result, these operations can be very expensive, and this
detector looks for places where those methods might be invoked.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[
<p> This detector looks for finalizers that null out fields of a class.
This does not help the garbage collector in any way, the nulling out of fields has no effect.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[
<p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[
<p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[
<p> This detector looks for code containing useless conditions like the second condition in this expression: (x >= 10 && x >= 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods that are unsupported.
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[
<p> Checks for incorrect format strings.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[
<p> Checks for equals methods that check for their operand being an instance of a class
that is not compatible with the class defining the equals method.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[
<p> This detector finds code that behaves differently under OpenJDK 1.6, where
weak references are used to hold onto Loggers.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[
<p> This detector generates a random signal: warnings that are just based on
hash values of the operations performed by methods.
These warnings are bogus random noise, intended to be useful
        as a control in data mining experiments, not in finding actual bugs in software.

 This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[
<p> Noisy detector for null dereferences. Intended to be used as a control in experiments
about the validity or predictive ability of warnings, not as a way to find problems in code.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[
<p> This detector looks for string constants that are duplicated across multiple classfiles.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[
<p> Look for code that should be executed inside doPrivileged blocks.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[
<p> Checks that all references call be resolved.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[
<p> This detector looks for switch statements containing fall through.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for places where a field is assigned
by reading the value of the same field.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[
<p> This detector looks for suspicious uses of non-short-circuiting
boolean operators (<code>|</code> and <code>&amp;</code> instead of
<code>||</code> and <code>&amp;&amp;</code>).</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[
<p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[
<p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
cloneable classes. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
classes that implement <code>Comparator</code>. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> This detector looks for code where an exception is caught,
but nothing is done to handle the exception.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[
<p> Looks for loads of values known to be null.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[
<p> This detector looks for bad arguments being passed to methods
(e.g., substring(0)).
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> This detector looks for calls to pointless methods,
such as the no-argument String constructor.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[
<p> This detector looks for covariant array assignments like Object[] array = new String[10] which may cause ArrayStoreException at runtime.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[
<p> Looks for calls to Number constructors with primitive arguments.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[
<p> This detector looks for calls to finalize() and other finalizer-related
issues.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[
<p> This detector looks for problems in the definition of the hashCode() and equals()
methods.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[
<p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to notify() that don't seem
to modify mutable object state.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[
<p> This detector looks for methods that return mutable static data.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[
<p> This detector looks for calls to Thread.run().  It is a fast
detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[
<p> This detector looks for loops that spin reading from a field.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() with two (or more) locks held.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() not in a conditional or loop.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[
<p> This detector looks for reads of uninitialized fields in constructors.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[
<p> This detector looks for get and set methods where the get is unsynchronized
while the set is synchronized.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[
<p> This detector looks for potentially circular class initialization
dependencies.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[
<p> This detector looks for problems in how Iterator classes are defined.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[
<p> This detector looks for comparisons of String objects using the == or !=
operators.
 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[
<p> This detector looks for synchronization on objects read from
modified fields.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[
<p> This detector looks for code that seems to be synchronizing on a field in order
to guard updates of that field.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[
<p> This detector looks for static fields that may be modified by
malicious code.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[
<p> This detector looks for suspiciously-named methods.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[
<p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
return value is ignored.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[
<p> This detector looks for potential problems in the implementation
of Serializable classes.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[
<p> This detector looks for constructors that start threads.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[
<p> This detector looks for incorrect for loops.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[
<p> Looks for explicit serialization via readObject and
    writeObject as evidence
that this class is, indeed, serialized. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[
<p> This detector looks for fields whose value is never read.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() that are not in a loop.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[
<p> This detector looks for problems in Comparator.compare or Comparable.compareTo implementation.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur.  It also looks for redundant comparisons of reference values against
null.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur, and the use of non-short-circuit evaluation causes the usual techniques to fail.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> This detector looks for IO stream objects which do not escape the
method and do not appear to be closed on all paths out of the method.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> This detector looks for methods that return either arrays or an explicit null reference.
Returning a zero length array is generally preferred in this context to returning a null reference.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> This detector looks for control flow statements which have no effect.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
locks which are acquired, but not released on all paths out of the method.&nbsp;
It is a moderately fast detector.&nbsp; Note that in order to use this
detector, you need to have the <code>java.util.concurrent</code> package
in the auxiliary classpath (or be analyzing the package itself).</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where two reference values are compared
with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>)
where comparing reference values is generally an error.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait(), notify(), or notifyAll()
which do not appear to be made on an object which is currently locked.&nbsp;
It is a moderately fast detector.&nbsp; <b>This detector is disabled because
it is still under development, and produces too many false positives.</b></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[
<p> This detector looks for empty synchronized blocks.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[
<p> This detector looks for self assignments of local variables.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[
<p> This detector looks for suspicious bitwise logical expressions.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> This detector looks for lazy field initialization where the
field is not volatile.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[
<p> This detector looks for ordinary synchronization performed
on JSR166 locks.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[
<p> This detector looks for private methods that are never called.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[
<p> This detector looks for String concatenation in loops using +.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[
<p> This detector looks for objects initialized within loop which can be moved outside for better performance.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[
<p> This detector looks for code that uses String.indexOf(String) or String.lastIndexOf(String),
passing a constant string of length 1. It is recommended to use the more efficient integer implementations.
A fast detector.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[
<p> This detector looks for code that converts Collections to arrays
using the toArray() method that takes a prototype array, passing
an array argument which is zero-length.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientReplaceAll">
    <Details>
<![CDATA[
<p> This detector finds occurrences of replaceAll(String regex, String replacement) without any special regex characters. 
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[
<p> This detector looks for JUnit tests that are malformed.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[
<p> This detector looks for code that extends an Adapter class and overrides a Listener
method with the wrong signature. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[
<p> This detector looks for calls to getXXX or setXXX methods of a result set where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[
<p> This detector looks for type checks using the instanceof operator where the determination
can be done statically. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[
<p>
This detector looks for Applet constructors that call methods in the parent
Applet that rely on the Applet stub. Since this stub isn't initialized until just
before the init() method, these methods will fail in the constructor.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[
<p>
This detector looks for calls to Thread.interrupted() from a non-static context. If it is called from
Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted().
However if it is called on an arbitrary thread object, it is most probably an error, as interrupted()
is always called on the current thread.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[
<p>
This detector uses data flow analysis to look for invocations of execute methods
on SQL statements in which something other than a constant string is passed as an argument.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[
<p>
This detector looks for assignments to local variables that
are never subsequently read. It is a moderately fast detector.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[
<p> This detector looks for class level fields that are masked by
local fields defined in methods.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[
<p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from
a keySet iterator. </p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[
<p> This detector looks for code that creates objects based on classes that only define static methods.
</p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[
<p> This detector looks for catch clauses that catch Exception,
when no code in the block throws Exception. </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[
<p> Looks for floating point equality expressions. A fast detector. </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[
<p>This detector looks for I/O streams and database resources that
are not cleaned up on all paths out of a method.  This is a slow detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[
<p>This detector looks for code that calls java.lang.Math static methods on constant values,
where the resultant value is a statically known constant. It is faster, and sometimes more
accurate, to use the constant instead.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[
<p>This detector looks for circular dependencies among classes. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[
<p>This detector looks for classes that declare they implement the same interface
as a super class. This is redundant, if a superclass implements an interface, so does
the subclass.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[
<p>This detector looks for potential problems in implementing the Struts framework.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[
<p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll()
on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class.
Clients of the class may use an instance of the class as its own synchronizing object, and cause
havoc to the base implementation.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[
<p>
This detector looks for places where the result of integer division is
cast to double. Often, what was meant was to cast the integer operands
to double and then perform the division.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[
<p>
This detector looks for bad casts of object references using data flow analysis.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[
<p>
This detector looks for stores of non Serializable objects into HTTP sessions.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[
<p>
This detector looks for uses of non Serializable objects in contexts that require them to be serializable.
</p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[
<p>
This detector looks for non Serializable objects passed to the writeObject method of
an ObjectOutput.
</p>
]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[
<p> This detector looks for regular expressions that have invalid syntax.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[
<p> This detector looks for miscellaneous small errors
mentioned by Joshua Bloch and Neal Gafter in
their work on Programming Puzzlers.
  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[
      <p>
         This detector looks for calls to Thread.sleep() made with
         a lock held.  It is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[
<p> This detector looks for if/else or switch statements that have the
same code for two branches, thus rendering the test useless. This often
is caused by copying and pasting the two branches, causing incorrect logic
for the one branch.</p><p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[
<p> This detector looks for internal classes that write to member variables of the
owning class, when that member variable is private. In this case, a special compiler
generated accessor method needs to be used to write to this variable. Relaxing the
visibility to protected will allow the field to be directly written.</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[
<p> This detector looks for direct allocations of implementations of XML interfaces.
This ties the code to a specific implementation, rather than using the supplied
factory pattern to create these objects.</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[
      <p>
      This detector looks for subclasses that implement methods defined in the super
      class, that only pass the parameters untouched to the parent class method.
      These methods can just be removed.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[
      <p>
      This detector looks for final classes that declare protected members. As this
      class can not be derived from, the use of protected access for members is
      incorrect. The access should be changed to public or private to represent
      the correct intention of the field. This was probably caused by a change in
      use for this class, without completely changing all of the class to the new
      paradigm.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[
      <p>
      This detector looks for simple assignments of literal boolean values to variables in
      conditional expressions.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[
      <p>
      TrainNullReturnValues determines which methods may return null and saves
      them to a file.  The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[
      <p>
      TrainUnconditionalParamDerefs determines which methods may
      unconditionally dereference parameters and saves them to a file.
      The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[
      <p>
      TrainFieldStoreTypes analyzes the types stored into fields
      and stores them to a database.  The database may be used in a later
      pass to make type analysis more precise.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
      TrainNonNullAnnotations collects @Nonnull and @PossiblyNull annotations
      and stores them to database files.  This is a fast detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[
      <p>This detector is just for debugging method call resolution in SpotBugs.
      Don't enable it.</p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p> This detector just collects summary statistics information about the analysis process. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[
    <p>
    This detector is a code example showing how to write a SpotBugs
    detector using the ASM bytecode analysis framework.
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[
    <p> This detector looks at the arguments of calls to generic
    collection methods that receive a <code>java.lang.Object</code>
    to see if the argument's type is related to the collection's
    parameter. Arguments with unrelated class types are never going
    to be in the collection. For example, if <code>foo</code> is a
    <code>List&lt;String&gt;</code> and <code>bar</code> is a
    <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>
    will always return false. This is a fast detector.
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[
<p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because
 Calendars are inherently unsafe for multithreaded use.
</p>
]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[
          <p>This is an internal detector used only for testing dataflow analyses.
          It is not enabled by default.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[
        <p>Check for violations of properties specified by JSR-305
        type qualifier annotations.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[
        <p>Looks for an attempt to append to an object output stream.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[
          <p>Checks @ExpectedWarning and @NoWarning annotations.
          This detector is used only for testing SpotBugs.</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[
          <p>Checks that if the result of putIfAbsent is ignored,
            the value passed as the second argument is not reused. </p>
          ]]>
      </Details>
  </Detector>
  <Detector
    class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[
          <p>Checks for methods invoked from constructors for superclasses.  </p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[
<p> Checks for calls to methods which perform a byte to String (or String to byte) conversion using the user's default
 platform encoding. This can cause the application behaviour to vary between platforms.  </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[
        <p>Checks that overriding methods do not relax @Nonnull (made @CheckForNull) on return values
        or @CheckForNull (made @Nonnull) on parameters.</p>
      ]]>
      </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>
          通过double构造的Bigdecimal变量会有精度问题, 建议直接使用字符串构造
        </ShortDescription>
        <LongDescription>
          在{1}中, BigDecimal是由{4}类型构造的, 会有精度问题, 建议直接使用字符串构造
        </LongDescription>
        <Details>
      <![CDATA[
    <p>
This code creates a BigDecimal from a double value that doesn't translate well to a
decimal number.
For example, one might assume that writing new BigDecimal(0.1) in Java creates a BigDecimal which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625.
You probably want to use the BigDecimal.valueOf(double d) method, which uses the String representation
of the double to create the BigDecimal (e.g., BigDecimal.valueOf(0.1) gives 0.1).
</p>

]]>
    </Details>
    </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>
      更改ScheduledThreadPoolExecutor最大线程池的大小不会生效
    </ShortDescription>
    <LongDescription>
      在{1}中, 更改ScheduledThreadPoolExecutor最大线程池的大小不会生效
    </LongDescription>
    <Details>
      <![CDATA[
    <p>(<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>)
While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.
    </p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>
      死循环
    </ShortDescription>
    <LongDescription>
      死循环
    </LongDescription>
    <Details>
<![CDATA[
<p>This loop doesn't seem to have a way to terminate (other than by perhaps
throwing an exception).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>
      无穷的递归调用
    </ShortDescription>
    <LongDescription>
      无穷的递归调用
    </LongDescription>
    <Details>
<![CDATA[
<p>This method unconditionally invokes itself. This would seem to indicate
an infinite recursive loop that will result in a stack overflow.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>
      将数组声明为volatile类型, 他的子元素并不是volatile类型的
    </ShortDescription>
    <LongDescription>{1}数组被声明为volatile类型, 但是他的子元素并不是volatile类型的</LongDescription>
    <Details>
<![CDATA[
<p>This declares a volatile reference to an array, which might not be what
you want. With a volatile reference to an array, reads and writes of
the reference to the array are treated as volatile, but the array elements
are non-volatile. To get volatile array elements, you will need to use
one of the atomic array classes in java.util.concurrent (provided
in Java 5.0).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>
      对一个volatile类型的字段进行自增, 这种操作并不是原子性的
    </ShortDescription>
    <LongDescription>
      在{1}中, 对一个volatile类型的字段{2}进行自增, 这种操作并不是原子性的
    </LongDescription>
    <Details>
<![CDATA[
<p>This code increments a volatile field. Increments of volatile fields aren't
atomic. If more than one thread is incrementing the field at the same time,
increments could be lost.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>
      当一个类被子类继承后, 使用this.getClass().getResource(...)来获取资源是不安全的
    </ShortDescription>
    <LongDescription>
      当一个类被子类继承后, 使用{1}来获取资源是不安全的
    </LongDescription>
    <Details>
<![CDATA[
<p>Calling <code>this.getClass().getResource(...)</code> could give
results other than expected if this class is extended by a class in
another package.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
    <ShortDescription>
      不要在返回值为Boolean类型的方法中直接返回null, 这样会导致空指针异常
    </ShortDescription>
    <LongDescription>
      不要在返回值为Boolean类型的{1}中直接返回null, 这样会导致空指针异常
    </LongDescription>
    <Details>
       <![CDATA[
       <p>
    A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen.
    This method can be invoked as though it returned a value of type boolean, and
    the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
    this will result in a NullPointerException.
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>
      不要在带有Optional返回类型的方法中返回null
    </ShortDescription>
    <LongDescription>
      不要在Optional返回类型的方法{1}中返回null
    </LongDescription>
    <Details>
       <![CDATA[
       <p>
    The usage of Optional return type (java.util.Optional or com.google.common.base.Optional)
    always means that explicit null returns were not desired by design.
    Returning a null value in such case is a contract violation and will most likely break client code.
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>
      不要对可能为null的对象进行Synchronize操作
    </ShortDescription>
    <LongDescription>
      在{1}中不要对可能为null的对象{2.givenClass}进行Synchronize操作
    </LongDescription>
    <Details>
<![CDATA[
<p>Since the field is synchronized on, it seems not likely to be null.
If it is null and then synchronized on a NullPointerException will be
thrown and the check would be pointless. Better to synchronize on
another field.</p>

]]>
     </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>
      不要使用float类型变量进行数学运算, 建议使用double类型
    </ShortDescription>
    <LongDescription>
      不要在{1}中使用float类型变量进行数学运算, 建议使用double类型
    </LongDescription>
    <Details>
<![CDATA[
<p>
   The method performs math operations using floating point precision.
   Floating point precision is very imprecise. For example,
   16777216.0f + 1.0f = 16777216.0f. Consider using double math instead.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>
      不要使用java未来版本预留关键字作为标识符
    </ShortDescription>
    <LongDescription>
      不要使用java未来版本预留关键字{2}作为标识符
    </LongDescription>
    <Details>
<![CDATA[
<p>The identifier is a word that is reserved as a keyword in later versions of Java, and your code will need to be changed
in order to compile it in later versions of Java.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>
      不要把线程对象作为参数传给带Runnable参数方法
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要把线程对象作为参数传给带Runnable参数方法
    </LongDescription>
    <Details>
<![CDATA[
  <p> A Thread object is passed as a parameter to a method where
a Runnable is expected. This is rather unusual, and may indicate a logic error
or cause unexpected behavior.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>
      不要使用Maps和sets的集合类型的URLs, 这可能会出现性能问题
    </ShortDescription>
    <LongDescription>不要使用Maps和sets的集合类型的URLs, 这可能会出现性能问题</LongDescription>
    <Details>
<![CDATA[
  <p> This method or field is or uses a Map or Set of URLs. Since both the equals and hashCode
method of URL perform domain name resolution, this can result in a big performance hit.
See <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> for more information.
Consider using <code>java.net.URI</code> instead.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>
      不要调用URL的equals或hashcode方法, 会有性能问题, 考虑使用java.net.URI来代替
    </ShortDescription>
    <LongDescription>
      不要调用URL的equals或hashcode方法, 会有性能问题, 考虑使用java.net.URI来代替
    </LongDescription>
    <Details>
<![CDATA[
  <p> The equals and hashCode
method of URL perform domain name resolution, this can result in a big performance hit.
See <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> for more information.
Consider using <code>java.net.URI</code> instead.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>
      想在运行时通过反射获取注解信息, 该注解必须声明为运行时注解
    </ShortDescription>
    <LongDescription>
      想在运行时通过反射获取{3}注解信息, 该注解必须声明为运行时注解
    </LongDescription>
    <Details>
<![CDATA[
  <p> Unless an annotation has itself been annotated with  @Retention(RetentionPolicy.RUNTIME), the annotation can't be observed using reflection
(e.g., by using the isAnnotationPresent method).
   .</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>
      使用new String方式创建字符串是低效的行为
    </ShortDescription>
    <LongDescription>使用new String方式创建字符串是低效的行为</LongDescription>
    <Details>
<![CDATA[
  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>
      -128到127之间的数字再jvm中存在缓存的对象, 推荐使用valueOf来获取对应引用
    </ShortDescription>
    <LongDescription>
      -128到127之间的数字再jvm中存在缓存的对象, 推荐使用valueOf来获取对应引用
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      Using <code>new Integer(int)</code> is guaranteed to always result in a new object whereas
      <code>Integer.valueOf(int)</code> allows caching of values to be done by the compiler, class library, or JVM.
      Using of cached values avoids object allocation and the code will be faster.
      </p>
      <p>
      Values between -128 and 127 are guaranteed to have corresponding cached instances
      and using <code>valueOf</code> is approximately 3.5 times faster than using constructor.
      For values outside the constant range the performance of both styles is the same.
      </p>
      <p>
      Unless the class must be compatible with JVMs predating Java 1.5,
      use either autoboxing or the <code>valueOf()</code> method when creating instances of
      <code>Long</code>, <code>Integer</code>, <code>Short</code>, <code>Character</code>, and <code>Byte</code>.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>
      java.util.concurrent.locks.Condition对象等待时应该掉用await()方法
    </ShortDescription>
    <LongDescription>
      java.util.concurrent.locks.Condition对象等待时应该掉用await()方法
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method calls <code>wait()</code> on a
      <code>java.util.concurrent.locks.Condition</code> object.&nbsp;
      Waiting for a <code>Condition</code> should be done using one of the <code>await()</code>
      methods defined by the <code>Condition</code> interface.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>{1}生成了从0到1的随机值, 但是被强制转化成了整数0</ShortDescription>
    <LongDescription>
      {1}生成了从0到1的随机值, 但是被强制转化成了整数0
    </LongDescription>
    <Details>
<![CDATA[
  <p>A random value from 0 to 1 is being coerced to the integer value 0. You probably
want to multiply the random value by something else before coercing it to an integer, or use the <code>Random.nextInt(n)</code> method.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
    <ShortDescription>
      错误的组合了Math.max和Math.min方法
    </ShortDescription>
    <LongDescription>错误的组合了Math.max和Math.min方法</LongDescription>
    <Details>
<![CDATA[
  <p>This code tries to limit the value bounds using the construct like Math.min(0, Math.max(100, value)). However the order of
  the constants is incorrect: it should be Math.min(100, Math.max(0, value)). As the result this code always produces the same result
  (or NaN if the value is NaN).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>
      不要使用nextDouble()方法产生Integer类型变量, 考虑使用nextInt()方法
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要使用nextDouble()方法产生Integer类型变量, 考虑使用nextInt()方法
    </LongDescription>
    <Details>
<![CDATA[
  <p>If <code>r</code> is a <code>java.util.Random</code>, you can generate a random number from <code>0</code> to <code>n-1</code>
using <code>r.nextInt(n)</code>, rather than using <code>(int)(r.nextDouble() * n)</code>.
</p>
<p>The argument to nextInt must be positive. If, for example, you want to generate a random
value from -99 to 0, use <code>-r.nextInt(100)</code>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>可能会产生局部初始化的对象</ShortDescription>
    <LongDescription>可能会产生局部初始化的对象</LongDescription>
    <Details>
<![CDATA[
  <p>Looks like this method uses field initialization with double-checked locking.
  While the field is correctly declared as volatile, it's possible that the internal structure of
  the object is changed after the field assignment, thus another thread may see the partially initialized object.</p>
  <p>To fix this problem consider storing the object into the local variable first
  and save it to the volatile field only after it's fully constructed.
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>
      直接写死了类名, 会导致派生类无法使用equals方法
    </ShortDescription>
    <LongDescription>
      直接写死了类名, 会导致派生类无法使用equals方法
    </LongDescription>
    <Details>
<![CDATA[
  <p> This class has an equals method that will be broken if it is inherited by subclasses.
It compares a class literal with the class of the argument (e.g., in class <code>Foo</code>
it might check if <code>Foo.class == o.getClass()</code>).
It is better to check if <code>this.getClass() == o.getClass()</code>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>
      不要在多个类中声明巨大的字符串常量
    </ShortDescription>
    <LongDescription>不要在多个类中声明巨大的字符串常量</LongDescription>
    <Details>
      <![CDATA[
      <p>
    A large String constant is duplicated across multiple class files.
    This is likely because a final field is initialized to a String constant, and the Java language
    mandates that all references to a final field from other classes be inlined into
that classfile. See <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475">JDK bug 6447475</a>
    for a description of an occurrence of this bug in the JDK and how resolving it reduced
    the size of the JDK by 1 megabyte.
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
    <ShortDescription>
      方法没有检测参数是否为null
    </ShortDescription>
    <LongDescription>
      {1}方法没有检测参数是否为null
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_REF_BUILD_FROM_JSON_MIGHT_BE_NULL_BUT_DEREFED_WITHOUT_NULLCHECK">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 对该对象的调用可能会产生空指针异常, 请进行Null Check
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性有可能为null, 对该对象的调用可能会产生空指针异常, 请进行Null Check
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PASS_JSON_FIELD_TO_NONNULL_PARAM_VIOLATION">
    <ShortDescription>
      通过反序列化获得的对象属性有可能为null, 而目标方法中对该对象没有进行控制检查, 这种情况下有可能出现空指针异常
    </ShortDescription>
    <LongDescription>
      通过反序列化获得的对象属性有可能为null, 而目标方法中对该对象没有进行控制检查, 这种情况下有可能出现空指针异常
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    A parameter to this method has been identified as a value that should
    always be checked to see whether or not it is null, but it is being dereferenced
    without a preceding null check.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>
      变量调用equals方法时没有进行是否为null的判断
    </ShortDescription>
    <LongDescription>
    {1}调用equals方法时没有进行是否为null的判断
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      This implementation of equals(Object) violates the contract defined
      by java.lang.Object.equals() because it does not check for null
      being passed as the argument.  All equals() methods should return
      false if passed a null value.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>
      double或float比较时没有考虑到-0.0 and NaN, 可能会导致错误结果
    </ShortDescription>
    <LongDescription>double或float比较时没有考虑到-0.0 and NaN, 可能会导致错误结果</LongDescription>
    <Details>
<![CDATA[
  <p>This method compares double or float values using pattern like this: val1 &gt; val2 ? 1 : val1 &lt; val2 ? -1 : 0.
This pattern works incorrectly for -0.0 and NaN values which may result in incorrect sorting result or broken collection
(if compared values are used as keys). Consider using Double.compare or Float.compare static methods which handle all
the special cases correctly.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>servlet中的可变字段会导致多线程竞态条件</ShortDescription>
    <LongDescription>
      servlet中的可变字段会导致多线程竞态条件
    </LongDescription>
    <Details>
<![CDATA[
<p>A web server generally only creates one instance of servlet or JSP class (i.e., treats
the class as a Singleton),
and will
have multiple threads invoke methods on that instance to service multiple
simultaneous requests.
Thus, having a mutable instance field generally creates race conditions.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>错误的synchronize用法
    </ShortDescription>
    <LongDescription>错误的synchronize用法 {1}; locked {2}% of time</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  </p>
  <ul>
  <li> The class contains a mix of locked and unlocked accesses,</li>
  <li> The class is <b>not</b> annotated as javax.annotation.concurrent.NotThreadSafe,</li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ul>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>推荐使用synchronize方法来进行线程同步</ShortDescription>
    <LongDescription>推荐使用synchronize方法来进行线程同步</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>
      等待两个持有锁的对象, 这可能会发生死锁
    </ShortDescription>
    <LongDescription>等待两个持有锁的对象, 这可能会发生死锁</LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.
   &nbsp;
   Performing a wait only releases the lock on the object
   being waited on, not any other locks.
   &nbsp;
This not necessarily a bug, but is worth examining
  closely.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>
      不要在构造函数中调用可能被子类重写的方法, 这些方法还没有初始化
    </ShortDescription>
    <LongDescription>
      不要在构造函数中调用可能被子类重写的方法, 这些方法还没有初始化
    </LongDescription>
    <Details>
<![CDATA[
  <p> This method is invoked in the constructor of the superclass. At this point,
    the fields of the class have not yet initialized.</p>
<p>To make this more concrete, consider the following classes:</p>
<pre><code>abstract class A {
    int hashCode;
    abstract Object getValue();

    A() {
        hashCode = getValue().hashCode();
    }
}

class B extends A {
    Object value;

    B(Object v) {
        this.value = v;
    }

    Object getValue() {
        return value;
    }
}
</code></pre>
<p>When a <code>B</code> is constructed,
the constructor for the <code>A</code> class is invoked
<em>before</em> the constructor for <code>B</code> sets <code>value</code>.
Thus, when the constructor for <code>A</code> invokes <code>getValue</code>,
an uninitialized value is read for <code>value</code>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>
      这个类包含get和set方法, set方法是同步方法而get方法是非同步方法, 这可能会导致在运行时发生异常
    </ShortDescription>
    <LongDescription>{1} is unsynchronized, {2} is synchronized
      这个类包含get和set方法, set方法是同步方法而get方法是非同步方法, 这可能会导致在运行时发生异常
    </LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>
      两个类的静态初始化块中存在交叉引用的情况, 可能导致初始化时发生异常
    </ShortDescription>
    <LongDescription>{0}和{1}两个类的静态初始化块中存在交叉引用的情况, 可能导致初始化时发生异常</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>
      内部类在外部类未初始化之前使用外部类对象实例
    </ShortDescription>
    <LongDescription>内部类在外部类未初始化之前使用外部类对象实例</LongDescription>
    <Details>
<![CDATA[
  <p> During the initialization of a class, the class makes an active use of a subclass.
That subclass will not yet be initialized at the time of this use.
For example, in the following code, <code>foo</code> will be null.</p>
<pre><code>public class CircularClassInitialization {
    static class InnerClassSingleton extends CircularClassInitialization {
        static InnerClassSingleton singleton = new InnerClassSingleton();
    }

    static CircularClassInitialization foo = InnerClassSingleton.singleton;
}
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>
      next方法没有够抛出NoSuchElementException
    </ShortDescription>
    <LongDescription>next方法没有够抛出NoSuchElementException</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>
      不要同步String型变量由于它被JVM中多个其他的对象所共有, 这样在其他代码中会引发死锁
    </ShortDescription>
    <LongDescription>Synchronization on interned String in {1}
      在{1}中, 不要同步String型变量由于它被JVM中多个其他的对象所共有, 这样在其他代码中会引发死锁
    </LongDescription>
    <Details>
<![CDATA[
  <p> The code synchronizes on interned String.</p>
<pre><code>private static String LOCK = "LOCK";
...
synchronized(LOCK) {
    ...
}
...
</code></pre>
<p>Constant Strings are interned and shared across all other classes loaded by the JVM. Thus, this code
is locking on something that other code might also be locking. This could result in very strange and hard to diagnose
blocking and deadlock behavior. See <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> and <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.
</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>
      不要同步一个原始封装的Boolean型变量, 该变量实例可能会被其他类使用
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要同步一个原始封装的Boolean型变量, 该变量实例可能会被其他类使用
    </LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as a Boolean.</p>
<pre><code>private static Boolean inited = Boolean.FALSE;
...
synchronized(inited) {
    if (!inited) {
        init();
        inited = Boolean.TRUE;
    }
}
...
</code></pre>
<p>Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock.</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>
      不要同步一个封装的基本变量的值, 该变量实例可能会被其他类使用
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要同步一个封装的基本变量的值, 该变量实例可能会被其他类使用
    </LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on an apparently unshared boxed primitive,
such as an Integer.</p>
<pre><code>private static final Integer fileLock = new Integer(1);
...
synchronized(fileLock) {
    .. do something ..
}
...
</code></pre>
<p>It would be much better, in this code, to redeclare fileLock as</p>
<pre><code>private static final Object fileLock = new Object();
</code></pre>
<p>
The existing code might be OK, but it is confusing and a
future refactoring, such as the "Remove Boxing" refactoring in IntelliJ,
might replace this with the use of an interned Integer object shared
throughout the JVM, leading to very confusing behavior and potential deadlock.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>
      不要同步一个封装的基本类型变量, 该变量实例可能会被其他类使用
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要同步一个封装的基本类型变量, 该变量实例可能会被其他类使用
    </LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as an Integer.</p>
<pre><code>private static Integer count = 0;
...
synchronized(count) {
    count++;
}
...
</code></pre>
<p>Since Integer objects can be cached and shared,
this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock.</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>无效的同步操作</ShortDescription>
    <LongDescription>无效的同步操作</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on a field in what appears to be an attempt
to guard against simultaneous updates to that field. But guarding a field
gets a lock on the referenced object, not on the field. This may not
provide the mutual exclusion you need, and other threads might
be obtaining locks on the referenced objects (for other purposes). An example
of this pattern would be:</p>
<pre><code>private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
     Long result = null;
     synchronized(myNtfSeqNbrCounter) {
         result = new Long(myNtfSeqNbrCounter.longValue() + 1);
         myNtfSeqNbrCounter = new Long(result.longValue());
     }
     return result;
}
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>不要在经常变化的字段上进行同步, 因为不同线程可能会将锁加在不同对象上</ShortDescription>
    <LongDescription>
      不要在经常变化的字段上进行同步, 因为不同线程可能会将锁加在不同对象上
    </LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object
   referenced from a mutable field.
   This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>
      不要在构造器中创建新的线程
    </ShortDescription>
    <LongDescription>{1} invokes {2}
      不要在构造器中创建新的线程
    </LongDescription>
    <Details>
<![CDATA[
  <p> The constructor starts a thread. This is likely to be wrong if
   the class is ever extended/subclassed, since the thread will be started
   before the subclass constructor is started.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>这个变量有可能为null, 请进行空值检查</ShortDescription>
    <LongDescription>变量{1}有可能为null, 请进行空值检查</LongDescription>
    <Details>
      <![CDATA[
  <p> The variable referenced at this point is known to be null due to an earlier
   check against null. Although this is valid, it might be a mistake (perhaps you
intended to refer to a different variable, or perhaps the earlier check to see if the
variable is null should have been a check to see if it was non-null).
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>
      在调用readline返回值的方法之前, 请先进行空值检查
    </ShortDescription>
    <LongDescription>
      在调用readline返回值的方法之前, 请先进行空值检查
    </LongDescription>
    <Details>
<![CDATA[
  <p> The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>
      在调用readline返回值的方法之前, 请先进行空值检查
    </ShortDescription>
    <LongDescription>
      在调用readline返回值的方法之前, 请先进行空值检查
    </LongDescription>
    <Details>
<![CDATA[
  <p> The result of invoking readLine() is immediately dereferenced. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>
      该字段未被初始化过
    </ShortDescription>
    <LongDescription>
      {2.name}字段未被初始化过
    </LongDescription>
    <Details>
<![CDATA[
  <p> The program is dereferencing a field that does not seem to ever have a non-null value written to it.
Unless the field is initialized via some mechanism not seen by the analysis,
dereferencing this value will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>
      不要读取一个没被初始化的public或者protected字段
    </ShortDescription>
    <LongDescription>
      不要读取一个没被初始化的public或者protected字段{2.name}
    </LongDescription>
    <Details>
<![CDATA[
  <p> The program is dereferencing a public or protected
field that does not seem to ever have a non-null value written to it.
Unless the field is initialized via some mechanism not seen by the analysis,
dereferencing this value will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>由于内部类为非static类, 他持有了外部对象的指针, 在放入threadlocal以后, 可能导致两者都释放不掉</ShortDescription>
    <LongDescription>由于内部类为非static类, 他持有了外部对象的指针, 在放入threadlocal以后, 可能导致两者都释放不掉</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but should probably be a static inner class.
  As it is, there is a serious danger of a deadly embrace between the inner class
  and the thread local in the outer class. Because the inner class isn't static,
  it retains a reference to the outer class.
  If the thread local contains a reference to an instance of the inner
  class, the inner and outer instance will both be reachable
  and not eligible for garbage collection.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针异常</ShortDescription>
    <LongDescription>空指针异常</LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a
<code>NullPointerException</code> when the code is executed.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>
      不要在一直为空的对象上调用close方法
    </ShortDescription>
    <LongDescription>
      在{1}中, 不要在一直为空的对象{2.givenClass}上调用close方法
    </LongDescription>
    <Details>
<![CDATA[
<p> close() is being invoked on a value that is always null. If this statement is executed,
a null pointer exception will occur. But the big risk here you never close
something that should be closed.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>
      不要为一个带有Notnull注解的变量赋值空值
    </ShortDescription>
    <LongDescription>
      不要为一个带有Notnull注解的变量赋值空值
    </LongDescription>
    <Details>
      <![CDATA[
<p> A value that could be null is stored into a field that has been annotated as @Nonnull. </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>在异常路径上, 该变量是空值</ShortDescription>
    <LongDescription>在异常路径上, 该变量是空值, 这将发生空指针异常</LongDescription>
    <Details>
<![CDATA[
<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because SpotBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that SpotBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>
      函数参数带有Nullable注解, 但是函数使用中并未进行空值判断
    </ShortDescription>
    <LongDescription>
      函数参数{2}带有Nullable注解, 但是函数使用中并未进行空值判断
    </LongDescription>
    <Details>
<![CDATA[
<p> This parameter is always used in a way that requires it to be non-null,
but the parameter is explicitly annotated as being Nullable. Either the use
of the parameter or the annotation is wrong.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>
      某些执行分支可能会出现空指针异常
    </ShortDescription>
    <LongDescription>
      某些执行分支可能会出现空指针异常
    </LongDescription>
    <Details>
<![CDATA[
<p> There is a branch of statement that, <em>if executed,</em>  guarantees that
a null value will be dereferenced, which
would generate a <code>NullPointerException</code> when the code is executed.
Of course, the problem might be that the branch or statement is infeasible and that
the null pointer exception can't ever be executed; deciding that is beyond the ability of SpotBugs.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>某些分支可能会出现空指针异常</ShortDescription>
    <LongDescription>某些分支可能会出现空指针异常</LongDescription>
    <Details>
<![CDATA[
<p> There is a branch of statement that, <em>if executed,</em>  guarantees that
a null value will be dereferenced, which
would generate a <code>NullPointerException</code> when the code is executed.
Of course, the problem might be that the branch or statement is infeasible and that
the null pointer exception can't ever be executed; deciding that is beyond the ability of SpotBugs.
Due to the fact that this value had been previously tested for nullness,
this is a definite possibility.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>前面逻辑出现异常时, 这里可能会出现空指针问题</ShortDescription>
    <LongDescription>前面逻辑出现异常时, 这里可能会出现空指针问题</LongDescription>
    <Details>
<![CDATA[
<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because SpotBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that SpotBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>
      方法的返回值可能为空值, 没有进行非空的检查就进行了使用, 这样可能会出现空指针异常
    </ShortDescription>
    <LongDescription>
      方法的返回值可能为空值, 没有进行非空的检查就进行了使用, 这样可能会出现空指针异常
    </LongDescription>
    <Details>
      <![CDATA[
<p> The return value from a method is dereferenced without a null check,
and the return value of that method is one that should generally be checked
for null.  This may lead to a <code>NullPointerException</code> when the code is executed.
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>可能为空值的参数传递给了带有非空值参数的方法</ShortDescription>
    <LongDescription>可能为空值的参数传递给了带有非空值参数的方法</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A possibly-null value is passed to a non-null method parameter.
    Either the parameter is annotated as a parameter that should
    always be non-null, or analysis has shown that it will always be
    dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法参数中声明为non-null类型的参数, 但是传入的只却为null</ShortDescription>
    <LongDescription>方法参数中声明为non-null类型的参数, 但是传入的只却为null</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A possibly-null value is passed at a call site where all known
      target methods require the parameter to be non-null.
    Either the parameter is annotated as a parameter that should
    always be non-null, or analysis has shown that it will always be
    dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
    <ShortDescription>可能为空值的参数传递给了带有非空值参数的方法</ShortDescription>
    <LongDescription>可能为空值的参数传递给了带有非空值参数的方法</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method call passes a null value for a non-null method parameter.
    Either the parameter is annotated as a parameter that should
    always be non-null, or analysis has shown that it will always be
    dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>可能为空值的参数传递给了带有非空值参数的方法</ShortDescription>
    <LongDescription>可能为空值的参数传递给了带有非空值参数的方法</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method passes a null value as the parameter of a method which
    must be non-null. Either this parameter has been explicitly marked
    as @Nonnull, or analysis has determined that this parameter is
    always dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>
      克隆方法的返回值可能为空
    </ShortDescription>
    <LongDescription>
      {1}方法的返回值可能为空
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
    This clone method seems to return null in some circumstances, but clone is never
    allowed to return a null value.  If you are convinced this path is unreachable, throw an AssertionError
    instead.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>toString方法可能返回null</ShortDescription>
    <LongDescription>toString方法可能返回null</LongDescription>
    <Details>
      <![CDATA[
      <p>
    This toString method seems to return null in some circumstances. A liberal reading of the
    spec could be interpreted as allowing this, but it is probably a bad idea and could cause
    other code to break. Return the empty string or some other appropriate string rather than null.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
    <ShortDescription>空指针问题</ShortDescription>
    <LongDescription>空指针问题</LongDescription>
    <Details>
          <![CDATA[
              <p>
              There is a statement or branch that if executed guarantees that
              a value is null at this point, and that
              value that is guaranteed to be dereferenced
              (except on forward paths involving runtime exceptions).
              </p>
        <p>Note that a check such as
            <code>if (x == null) throw new NullPointerException();</code>
            is treated as a dereference of <code>x</code>.</p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>前面程序进入异常分支后, 此处会抛出空指针问题</ShortDescription>
    <LongDescription>前面程序进入异常分支后, 此处会抛出空指针问题</LongDescription>
    <Details>
          <![CDATA[
              <p>
              There is a statement or branch on an exception path
                that if executed guarantees that
              a value is null at this point, and that
              value that is guaranteed to be dereferenced
              (except on forward paths involving runtime exceptions).
              </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>
      不要在所有的static final字段赋值之前, 去使用静态初始化的方法创建一个类的实例
    </ShortDescription>
    <LongDescription>
      不要在所有的static final字段赋值之前, 去使用静态初始化的方法创建一个类的实例{0}
    </LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>
      请确保关闭了IO流
    </ShortDescription>
    <LongDescription>
      请确保关闭了IO流
    </LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods that might close it,
or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>
      异常路径上没有关闭IO流
    </ShortDescription>
    <LongDescription>
      异常路径上没有关闭IO流
    </LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>控制语句后面跟着空语句, 是设计如此吗</ShortDescription>
    <LongDescription>控制语句后面跟着空语句, 是设计如此吗</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement in which control
flow follows to the same or following line regardless of whether or not
the branch is taken.
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:</p>
<pre><code>if (argv.length == 1);
    System.out.println("Hello, " + argv[0]);
</code></pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>equals的参数必定为null, 请检查</ShortDescription>
    <LongDescription>equals的参数必定为null, 请检查</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object), passing a null value as
the argument. According to the contract of the equals() method,
this call should always return <code>false</code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>把函数参数赋值给了参数自己, 是不是忘记写this了</ShortDescription>
    <LongDescription>把函数参数赋值给了参数自己, 是不是忘记写this了</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable, and there
is a field with an identical name.
assignment appears to have been ; e.g.</p>
<pre><code>    int foo;
    public void setFoo(int foo) {
        foo = foo;
    }
</code></pre>
<p>The assignment is useless. Did you mean to assign to the field instead?</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>Double.longBitsToDouble方法传递了int类型的参数, 会产生错误结果</ShortDescription>
    <LongDescription>Double.longBitsToDouble方法传递了int类型的参数, 会产生错误结果</LongDescription>
    <Details>
<![CDATA[
<p> The Double.longBitsToDouble method is invoked, but a 32 bit int value is passed
    as an argument. This almost certainly is not intended and is unlikely
    to give the intended result.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>
      创建的Random对象只使用过一次. 建议保存此对象以便于下次使用
    </ShortDescription>
    <LongDescription>
      在{1}中, 创建的Random对象只使用过一次, 建议保存此对象以便于下次使用
    </LongDescription>
    <Details>
<![CDATA[
<p> This code creates a java.util.Random object, uses it to generate one random number, and then discards
the Random object. This produces mediocre quality random numbers and is inefficient.
If possible, rewrite the code so that the Random object is created once and saved, and each time a new random number
is required invoke a method on the existing Random object to obtain it.
</p>

<p>If it is important that the generated Random numbers not be guessable, you <em>must</em> not create a new Random for each random
number; the values are too easily guessable. You should strongly consider using a java.security.SecureRandom instead
(and avoid allocating a new SecureRandom for each random number needed).
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true"> <!-- never generated? -->
    <ShortDescription>这个延迟加载的字段在多线程情况下会遇到问题</ShortDescription>
    <LongDescription>这个延迟加载的字段在多线程情况下会遇到问题</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>这个延迟加载的字段在多线程情况下回遇到问题</ShortDescription>
    <LongDescription>这个延迟加载的字段在多线程情况下回遇到问题</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>加载或更新这个字段在多线程情况下回遇到问题</ShortDescription>
    <LongDescription>加载或更新这个字段在多线程情况下回遇到问题</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a static field.
After the field is set, the object stored into that location is further updated or accessed.
The setting of the field is visible to other threads as soon as it is set. If the
further accesses in the method that set the field serve to initialize the object, then
you have a <em>very serious</em> multithreading bug, unless something else prevents
any other thread from accessing the stored object until it is fully initialized.
</p>
<p>Even if you feel confident that the method is never called by multiple
threads, it might be better to not set the static field until the value
you are setting it to is fully populated/initialized.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>
      方法中存在关闭数据库资源连接失败的情况
    </ShortDescription>
    <LongDescription>
      方法中存在关闭数据库资源连接失败的情况
    </LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>在异常情况下没有关闭数据库连接</ShortDescription>
    <LongDescription>在异常情况下没有关闭数据库连接</LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all exception paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>不要在循环中调用Connection.prepareStatement</ShortDescription>
    <LongDescription>不要在循环中调用Connection.prepareStatement</LongDescription>
    <Details>
<![CDATA[
<p> The method calls Connection.prepareStatement inside the loop passing the constant arguments.
If the PreparedStatement should be executed several times there's no reason to recreate it for each loop iteration.
Move this call outside of the loop.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>不要在循环中调用NodeList.getLength(), 每次这个长度都会被重新计算</ShortDescription>
    <LongDescription>不要在循环中调用NodeList.getLength(), 每次这个长度都会被重新计算</LongDescription>
    <Details>
<![CDATA[
<p> The method calls NodeList.getLength() inside the loop and NodeList was produced by getElementsByTagName call.
This NodeList doesn't store its length, but computes it every time in not very optimal way.
Consider storing the length to the variable before the loop.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>不要在循环中compile正则表达式</ShortDescription>
    <LongDescription>不要在循环中compile正则表达式</LongDescription>
    <Details>
<![CDATA[
<p> The method calls Pattern.compile inside the loop passing the constant arguments.
If the Pattern should be used several times there's no reason to compile it for each loop iteration.
Move this call outside of the loop or even into static final field.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>不要在循环中直接使用正则表达式</ShortDescription>
    <LongDescription>不要在循环中直接使用正则表达式</LongDescription>
    <Details>
<![CDATA[
<p> The method creates the same regular expression inside the loop, so it will be compiled every iteration.
It would be more optimal to precompile this regular expression using Pattern.compile outside of the loop.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>sql返回的result set中获取第0个元素会取得错误结果</ShortDescription>
    <LongDescription>sql返回的result set中获取第0个元素会取得错误结果</LongDescription>
    <Details>
<![CDATA[
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>prepared statement 中获取第0个元素会取得错误结果</ShortDescription>
    <LongDescription>prepared statement 中获取第0个元素会取得错误结果</LongDescription>
    <Details>
<![CDATA[
<p> A call to a setXXX method of a prepared statement was made where the
parameter index is 0. As parameter indexes start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>这个类与其他类之间存在循环引用</ShortDescription>
    <LongDescription>这个类与其他类之间存在循环引用</LongDescription>
    <Details>
   <![CDATA[
    <p>
    This class has a circular dependency with other classes. This makes building these classes
    difficult, as each is dependent on the other to build correctly. Consider using interfaces
    to break the hard dependency.
    </p>
    ]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>从servlet中派生出来的类不能使用实例变量</ShortDescription>
    <LongDescription>从servlet中派生出来的类不能使用实例变量</LongDescription>
    <Details>
   <![CDATA[
    <p>
    This class extends from a Servlet class, and uses an instance member variable. Since only
    one instance of a Servlet class is created by the J2EE framework, and used in a
    multithreaded way, this paradigm is highly discouraged and most likely problematic. Consider
    only using method local variables.
    </p>
    ]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>不要反回类中用于同步的对象</ShortDescription>
    <LongDescription>不要反回类中用于同步的对象</LongDescription>
    <Details>
   <![CDATA[
    <p>
    This class uses synchronization along with wait(), notify() or notifyAll() on itself (the this
    reference). Client classes that use this class, may, in addition, use an instance of this class
    as a synchronizing object. Because two classes are using the same object for synchronization,
    Multithread correctness is suspect. You should not synchronize nor call semaphore methods on
    a public reference. Consider using a internal private member variable to control synchronization.
    </p>
    ]]>
      </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>
      负数无法通过取余数为1来判断是否为奇数
    </ShortDescription>
    <LongDescription>Check for oddness that won't work for negative numbers in {1}
      负数无法通过取余数为1来判断是否为奇数
    </LongDescription>
    <Details>
<![CDATA[
<p>
The code uses x % 2 == 1 to check to see if a value is odd, but this won't work
for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check
for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
    <ShortDescription>
      不要在持有对象锁时调用Thread.sleep()
    </ShortDescription>
    <LongDescription>
      不要在持有对象锁时调用Thread.sleep()
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method calls Thread.sleep() with a lock held.  This may result
      in very poor performance and scalability, or a deadlock, since other threads may
      be waiting to acquire the lock.  It is a much better idea to call
      wait() on the lock, which releases the lock and allows other threads
      to run.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>java.util.Calendar类型的静态对象, 在多线程的情况下是不安全的</ShortDescription>
    <LongDescription>
      java.util.Calendar类型的静态对象, 在多线程的情况下是不安全的
    </LongDescription>
    <Details>
<![CDATA[
<p>Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multithreaded use.
Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the
application. Under 1.4 problems seem to surface less often than under Java 5 where you will probably see
random ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions in sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().</p>
<p>You may also experience serialization problems.</p>
<p>Using an instance field is recommended.</p>
<p>For more information on this see <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>
and <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>java.util.Calendar类型的静态对象, 在多线程的情况下是不安全的</ShortDescription>
    <LongDescription>
      java.util.Calendar类型的静态对象, 在多线程的情况下是不安全的
    </LongDescription>
    <Details>
<![CDATA[
<p>Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multithreaded use.
The detector has found a call to an instance of Calendar that has been obtained via a static
field. This looks suspicious.</p>
<p>For more information on this see <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579">JDK Bug #6231579</a>
and <a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997">JDK Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>
      实例的方法中同步不要直接使用类名, 如果这个类有子类集合, 那么子类集合中的对象将会在这
      个类的各个子类上进行同步, 这不是我们想要的效果, 请使用getClass方法
    </ShortDescription>
    <LongDescription>
      实例的方法中同步不要直接使用类名, 如果这个类有子类集合, 那么子类集合中的对象将会在这
      个类的各个子类上进行同步, 这不是我们想要的效果, 请使用getClass方法
    </LongDescription>
    <Details>
      <![CDATA[
      <p>
     This instance method synchronizes on <code>this.getClass()</code>. If this class is subclassed,
     subclasses will synchronize on the class object for the subclass, which isn't likely what was intended.
     For example, consider this code from java.awt.Label:</p>
<pre><code>private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (getClass()) {
        return base + nameCounter++;
    }
}
</code></pre>
     <p>Subclasses of <code>Label</code> won't synchronize on the same subclass, giving rise to a datarace.
     Instead, this code should be synchronizing on <code>Label.class</code></p>
<pre><code>private static final String base = "label";
private static int nameCounter = 0;

String constructComponentName() {
    synchronized (Label.class) {
        return base + nameCounter++;
    }
}
</code></pre>
      <p>Bug pattern contributed by Jason Mehrens</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
    <ShortDescription>
      释放资源失败
    </ShortDescription>
    <LongDescription>{1} may fail to clean up {2}
      释放资源失败
    </LongDescription>
    <Details>
          <![CDATA[
          <p>
          This method may fail to clean up (close, dispose of) a stream,
          database object, or other
          resource requiring an explicit cleanup operation.
          </p>

          <p>
          In general, if a method opens a stream or other resource,
          the method should use a try/finally block to ensure that
          the stream or resource is cleaned up before the method
          returns.
          </p>

          <p>
          This bug pattern is essentially the same as the
          OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
          bug patterns, but is based on a different
          (and hopefully better) static analysis technique.
          We are interested is getting feedback about the
          usefulness of this bug pattern.
          For sending feedback, check:
          </p>
          <ul>
            <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">contributing guideline</a></li>
            <li><a href="https://github.com/spotbugs/discuss/issues?q=">malinglist</a></li>
          </ul>

          <p>
          In particular,
          the false-positive suppression heuristics for this
          bug pattern have not been extensively tuned, so
          reports about false positives are helpful to us.
          </p>

          <p>
          See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
          a description of the analysis technique.
          </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>异常路径上释放资源失败</ShortDescription>
    <LongDescription>异常路径上释放资源失败</LongDescription>
    <Details>
          <![CDATA[
          <p>
          This method may fail to clean up (close, dispose of) a stream,
          database object, or other
          resource requiring an explicit cleanup operation.
          </p>

          <p>
          In general, if a method opens a stream or other resource,
          the method should use a try/finally block to ensure that
          the stream or resource is cleaned up before the method
          returns.
          </p>

          <p>
          This bug pattern is essentially the same as the
          OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
          bug patterns, but is based on a different
          (and hopefully better) static analysis technique.
          We are interested is getting feedback about the
          usefulness of this bug pattern.
          For sending feedback, check:
          </p>
          <ul>
            <li><a href="https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md">contributing guideline</a></li>
            <li><a href="https://github.com/spotbugs/discuss/issues?q=">malinglist</a></li>
          </ul>

          <p>
          In particular,
          the false-positive suppression heuristics for this
          bug pattern have not been extensively tuned, so
          reports about false positives are helpful to us.
          </p>

          <p>
          See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
          a description of the analysis technique.
          </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>发生异常时, 没有释放锁</ShortDescription>
    <LongDescription>{1} 发生异常时, 没有释放锁</LongDescription>
    <Details>
      <![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
</p>
<pre><code>Lock l = ...;
l.lock();
try {
    // do something
} finally {
    l.unlock();
}
</code></pre>
]]>
    </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">Analysis skipped</BugCode>
  <BugCode abbrev="IL">Infinite Loop</BugCode>
  <BugCode abbrev="VO">Use of volatile</BugCode>
  <BugCode abbrev="UI">Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">Covariant array assignment</BugCode>
  <BugCode abbrev="AT">Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">Input/Output problem</BugCode>
  <BugCode abbrev="IC">Initialization circularity</BugCode>
  <BugCode abbrev="SI">Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">Mutable servlet field</BugCode>
  <BugCode abbrev="IS">Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API misuse</BugCode>
  <BugCode abbrev="Dm">Dubious method used</BugCode>
  <BugCode abbrev="Bx">Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">Naked notify</BugCode>
  <BugCode abbrev="UW">Unconditional wait</BugCode>
  <BugCode abbrev="SP">Method spins on field</BugCode>
  <BugCode abbrev="DC">Double check pattern</BugCode>
  <BugCode abbrev="Wa">Wait not in loop</BugCode>
  <BugCode abbrev="No">Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">Method invokes run()</BugCode>
  <BugCode abbrev="It">Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">Mutable static field</BugCode>
  <BugCode abbrev="ME">Mutable enum field</BugCode>
  <BugCode abbrev="EI">Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">Confusing method name</BugCode>
  <BugCode abbrev="SS">Unread field should be static</BugCode>
  <BugCode abbrev="UuF">Unused field</BugCode>
  <BugCode abbrev="UrF">Unread field</BugCode>
  <BugCode abbrev="UwF">Unwritten field</BugCode>
  <BugCode abbrev="SIC">Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">Range checks</BugCode>
  <BugCode abbrev="RV">Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">Logger problem</BugCode>
  <BugCode abbrev="IA">Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">Path traversal</BugCode>
  <BugCode abbrev="XSS">Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">Bogus random warning</BugCode>
  <BugCode abbrev="RpC">Repeated conditional test</BugCode>
  <BugCode abbrev="OS">Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-operation</BugCode>
  <BugCode abbrev="INT">Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">Private method is never called</BugCode>
  <BugCode abbrev="UMAC">Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing coding rules</BugCode>
  <BugCode abbrev="IJU">Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">Switch case falls through</BugCode>
  <BugCode abbrev="SIO">Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">Use Object Equals</BugCode>
  <BugCode abbrev="STI">Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">Dead local store</BugCode>
  <BugCode abbrev="IP">Ignored parameter</BugCode>
  <BugCode abbrev="MF">Masked Field</BugCode>
  <BugCode abbrev="WMI">Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">RuntimeException capture</BugCode>
  <BugCode abbrev="FE">Test for floating point equality</BugCode>
  <BugCode abbrev="UM">Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">Useless code</BugCode>
  <BugCode abbrev="CNT">Rough value of known constant</BugCode>
  <BugCode abbrev="CD">Circular Dependencies</BugCode>
  <BugCode abbrev="RI">Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">Bad shift</BugCode>
  <BugCode abbrev="ICAST">Casting from integer values</BugCode>
  <BugCode abbrev="RE">Regular expressions</BugCode>
  <BugCode abbrev="SQL">Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">Questionable for loops</BugCode>
  <BugCode abbrev="VA">Vararg problems</BugCode>
  <BugCode abbrev="BC">Bad casts of object references</BugCode>
  <BugCode abbrev="IM">Questionable integer math</BugCode>
  <BugCode abbrev="ST">Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">Warning inspired by Joshua Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE error</BugCode>
  <BugCode abbrev="DB">Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">Version compatibility issue</BugCode>
  <BugCode abbrev="DP">Use doPrivileged</BugCode>
  <BugCode abbrev="GC">Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">SpotBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">Unintended contention or possible deadlock due to locking on shared objects</BugCode>
</MessageCollection>
